1.操作系统的运行机制
  计算机系统中，CPU执行两种不同性质的程序：一种是操作系统内核程序；第二种是用户自编程序或者系统外层的应用程序。这两种程序的作用不同，
前者是后者的管理者，因此“管理程序”要执行一些特权指令，所谓特权指令，是指计算机中不允许用户直接使用的指令，如I/O指令，置中断指令，
存取用于内存保护的寄存器，送程序状态字到程序状态字寄存器等指令，于是操作系统在具体实现上划分了用户态（目态）和核心态（管态），以区分
这两类程序。
2.操作系统内核
  2.1时钟管理
     1）.操作系统需要通过时钟管理，向用户提供标准的系统时间。
     2）.时钟中断的管理，可以进行进程的切换。比如，在分时系统中，采用时间片轮转调度的实现：在实时系统中，按截止时间控制运行的实现。
  2.2中断机制
     中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序，这样可以减少中断的处理时间，提高
系统并行处理能力。
  2.3原语
     原语的特点是：1）.它们处于操作系统的最底层，是最接近硬件的部分。
                   2）.这些程序的运行具有原子性----关中断
                   3）.这些程序的运行时间都比较短，而且调用频繁。
  2.4系统控制的数据结构及处理
     比如作业控制块，进程控制块（PCB），设备控制块，各类链表，消息队列，空闲区登记表，内存分配表等。为了实现管理，常见的操作有
     1）.进程管理：进程状态管理，进程调度和分配，创建和撤销进程控制块等。
     2）.存储器管理：存储器的空间分配和回收，内存信息保护程序，代码对换程序等。
     3）.设备管理：缓冲区管理，设备分配和回收。
所以，核心态指令实际上包括包括系统调用类指令和一些针对时钟，中断和原语的操作指令。
综上：
3.用户态和核心态
用户态：运行于用户态的代码则要受到处理器的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能
对任务状态段（TSS）中I/O许可位图（I/O Permission Bitmap）中规定的可访问端口进行直接访问。
内核态：核心态，或者特权态（与之相对应的是用户态），是操作系统内核所运行的模式。运行在该模式的代码，可以无限制地对系统存储、外部设备
进行访问。
4.用户态切换到内核态的3种方式
1) 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的
机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

2) 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就
转到了内核态，比如虚存缺页异常，程序的非法操作码，地址越界，算术溢出，一般是源自CPU执行指令内部的事件。异常不能被屏蔽。

3) 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断
信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，
系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

4、具体的切换步骤：
从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何
区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体
区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：
  1）从当前进程的描述符中提取其内核栈的ss0及esp0信息。
  2）使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停
执行的程序的下一条指令。
  3）将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。
    从用户态切换到核心态，要耗掉>100 cycle的CPU时钟。
